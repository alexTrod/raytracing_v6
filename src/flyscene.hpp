#ifndef __FLYSCENE__
#define __FLYSCENE__

// Must be included before glfw.
#include <GL/glew.h>

#include <GLFW/glfw3.h>

#include <tucano/effects/phongmaterialshader.hpp>
#include <tucano/mesh.hpp>
#include <tucano/shapes/camerarep.hpp>
#include <tucano/shapes/cylinder.hpp>
#include <tucano/shapes/sphere.hpp>
#include <tucano/utils/flycamera.hpp>
#include <tucano/utils/imageIO.hpp>
#include <tucano/utils/mtlIO.hpp>
#include <tucano/utils/objimporter.hpp>
#include "box.hpp"

class Flyscene {

public:
	Flyscene(void) {}

	/**
	 * @brief Initializes the shader effect
	 * @param width Window width in pixels
	 * @param height Window height in pixels
	 */
	void initialize(int width, int height);

	/**
	 * Repaints screen buffer.
	 **/
	virtual void paintGL();

	/**
	 * Perform a single simulation step.
	 **/
	virtual void simulate(GLFWwindow* window);

	/**
	 * Returns the pointer to the flycamera instance
	 * @return pointer to flycamera
	 **/
	Tucano::Flycamera* getCamera(void) { return &flycamera; }

	/**
	 * @brief Add a new light source
	 */
	void addLight(void) { lights.push_back(flycamera.getCenter()); }
	void addPointLight(void) { pointLights.push_back(flycamera.getCenter());}

	/**
	 * @brief Create a debug ray at the current camera location and passing
	 * through pixel that mouse is over
	 * @param mouse_pos Mouse cursor position in pixels
	 */
	void createDebugRay(const Eigen::Vector2f& mouse_pos, Eigen::Vector3f origin);

	/**
	 * @brief raytrace your scene from current camera position
	 */
	void raytraceScene(int width = 0, int height = 0);

	/**
	 * @brief trace a single ray from the camera passing through dest
	 * @param origin Ray origin
	 * @param dest Other point on the ray, usually screen coordinates
	 * @return a RGB color
	 */
	 //Eigen::Vector3f traceRay(Eigen::Vector3f &origin, Eigen::Vector3f &dest, Box &box);
	Eigen::Vector3f traceRay(Eigen::Vector3f& origin, Eigen::Vector3f& dest, vector<Box>& boxes, int level);
	bool intersect(const Eigen::Vector3f& destination, const Eigen::Vector3f& origin, Tucano::Face& face, float& new_intersection);
	float distance3f(Eigen::Vector3f vec1, Eigen::Vector3f vec2);
	bool bBoxIntersection(const vector<Box>& boxes, const Eigen::Vector3f& destination, const Eigen::Vector3f& origin);
	vector<Box> getMoreBoxes();
	//bool bBoxIntersection(const Box& box, const Eigen::Vector3f& destination, const Eigen::Vector3f& origin);
	Box getFullBox();

	Eigen::Vector3f computeDirectLight(Eigen::Vector4f currentColor, Tucano::Face hit, Eigen::Vector3f lightDirection, Eigen::Vector3f origin, Eigen::Vector3f destination);

	Eigen::Vector3f getCenterFace(Tucano::Face face);

	Eigen::Vector3f computeReflected(Eigen::Vector3f origin, Eigen::Vector3f destination, Eigen::Vector3f lightDirection, Tucano::Face hit, int level, vector<Box>& box);

	Eigen::Vector3f shade(int level, Tucano::Face hit, Eigen::Vector3f origin, Eigen::Vector3f destination, vector<Box>& box);
	Eigen::Vector3f smoothSurfacing(Eigen::Vector3f hitpoint, Tucano::Face face);
	Eigen::Vector3f shadow(Tucano::Face face, Eigen::Vector3f in_color);
	bool visibility(Tucano::Face face, vector<Eigen::Vector3f>& vec_list);

private:
	// A simple phong shader for rendering meshes
	Tucano::Effects::PhongMaterial phong;

	// A fly through camera
	Tucano::Flycamera flycamera;

	// the size of the image generated by ray tracing
	Eigen::Vector2i raytracing_image_size;

	// A camera representation for animating path (false means that we do not
	// render front face)
	Tucano::Shapes::CameraRep camerarep = Tucano::Shapes::CameraRep(false);

	// a frustum to represent the camera in the scene
	Tucano::Shapes::Sphere lightrep;

	Tucano::Shapes::Sphere pointLightRep;

	// light sources for ray tracing // sun
	vector<Eigen::Vector3f> lights;

	// light sources for ray tracing // sun
	vector<Eigen::Vector3f> pointLights;

	// Scene light represented as a camera
	Tucano::Camera scene_light;

	/// A very thin cylinder to draw a debug ray
	Tucano::Shapes::Cylinder ray = Tucano::Shapes::Cylinder(0.1, 1.0, 16, 64);

	// Scene meshes
	Tucano::Mesh mesh;

	/// MTL materials
	vector<Tucano::Material::Mtl> materials;
};

#endif // FLYSCENE